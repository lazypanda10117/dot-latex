\NeedsTeXFormat{LaTeX2e}
\PassOptionsToPackage{enable-debug}{expl3}
\RequirePackage{expl3}
\ProvidesExplPackage{declare-package}{01/13/2020}{}{}

\debug_off:n { check-declarations, check-expressions, deprecation, log-functions }

% Usage:
%   \declarepackage [ options ] { package-name }
%     [ do_i_load_bool ] [ prereq, packages ] [ antireq, packages ]
%     ( init code ) { config code }
%     [ load, after, packages ] [ load, before, packages ]

%   \declarepackageaddoptions { options } { package-name }
%   \declarepackageremoveoptions { options } { package-name }

%   \declarepackageaddprehook { packages } { commands }
%   \declarepackageaddposthook { packages } { commands }

%   \declarepackagebeforepackage { package-name } { code }
%   \declarepackageafterpackage { package-name } { code }

%   \declarepackageinclude


\RequirePackage{xparse}


\NewDocumentCommand { \declarepackage } { O{} m O{\c_true_bool} O{} O{} +D(){} +m O{} O{} }
  { \__declare_package_pkg:nnnxxxxxn { #2 } { #6 } { #7 } { #1 } { #4 } { #5 } { #8 } { #9 } { #3 } }


\NewDocumentCommand { \declarepackageaddoptions } { m m }
  { \__declare_package_add_options:nx { #2 } { #1 } }
\NewDocumentCommand { \declarepackageremoveoptions } { m m }
  { \__declare_package_remove_options:nx { #2 } { #1 } }


\NewDocumentCommand { \declarepackageaddprehook } { m m }
  { \__declare_package_add_pre_hooks:xx { #1 } { #2 } }
\NewDocumentCommand { \declarepackageaddposthook } { m m }
  { \__declare_package_add_post_hooks:xx { #1 } { #2 } }


\NewDocumentCommand { \declarepackagebeforepackage } { m +m }
  { \__declare_package_before_package:nn { #1 } { #2 } }
\NewDocumentCommand { \declarepackageafterpackage } { m +m }
  { \__declare_package_after_package:nn { #1 } { #2 } }


\NewDocumentCommand { \declarepackageinclude } {}
  { \__declare_package_incl: }


\NewDocumentCommand { \dpkg } {} { \declarepackage }
\NewDocumentCommand { \dpkgaddops } {} { \declarepackageaddoptions }
\NewDocumentCommand { \dpkgremops } {} { \declarepackageremoveoptions }
\NewDocumentCommand { \dpkgincl } {} { \declarepackageinclude }


%============
%% Internals
%============


\seq_new:N \g_declare_package_packages_seq
\seq_new:N \g_declare_package_should_load_packages_seq
\seq_new:N \g_declare_package_should_not_load_packages_seq
\seq_new:N \g_declare_package_prep_load_packages_seq
\seq_new:N \g_declare_package_load_packages_seq
\int_new:N \g_declare_package_lambda_int


\cs_new:Nn \__declare_package_incl:
  {
    \seq_map_inline:Nn \g_declare_package_packages_seq
      {
        \bool_if:cT { c_declare_package_ ##1 _pkg_load_bool }
          {
            \seq_if_in:NnF \g_declare_package_should_load_packages_seq { ##1 }
              { \__declare_package_should_load:n { ##1 } }
          }
      }
    \seq_map_inline:Nn \g_declare_package_should_load_packages_seq
      {
        \seq_if_in:NnF \g_declare_package_should_not_load_packages_seq { ##1 }
        %% {
        %%   \PackageError{declare-package}
        %%     {Package Collision.}
        %%     {Package `##1' is both enabled and an antireq.}
        %% }
        { \__declare_package_prep_load:n { ##1 } }
      }
    \seq_map_inline:Nn \g_declare_package_load_packages_seq
      { \__declare_package_load:n { ##1 } }
  }


% 1 name
\cs_new:Nn \__declare_package_should_load:n
  {
    \__declare_package_seq_ginsert:Nn \g_declare_package_should_load_packages_seq { #1 }
    \seq_map_inline:cn { g_declare_package_ #1 _pkg_antireqs_seq }
      { \__declare_package_seq_ginsert:Nn \g_declare_package_should_not_load_packages_seq { ##1 } }

    \seq_map_inline:cn { g_declare_package_ #1 _pkg_prereqs_seq }
      {
        \seq_if_in:NnF \g_declare_package_should_load_packages_seq { ##1 }
        { \__declare_package_should_load:n { ##1 } }
      }
  }


% 1 prev name, 2 cur name
\cs_new:Nn \__declare_package_prep_load:nn
  {
    \__declare_package_seq_ginsert:NnF \g_declare_package_prep_load_packages_seq { #2 }
      {
        \PackageError{declare-package}
          {Dependency tree must be a DAG.}
          {The dependency `#1' -- `#2' creates a dicycle.}
      }

    \__declare_package_prep_load:n { #2 }
  }


% 1 name
\cs_new:Nn \__declare_package_prep_load:n
  {
    \__declare_package_seq_ginsert:Nn \g_declare_package_prep_load_packages_seq { #1 }
    \seq_map_inline:cn { g_declare_package_ #1 _pkg_post_seq }
      {
        \seq_if_in:NnF \g_declare_package_load_packages_seq { ##1 }
          { \__declare_package_prep_load:nn { #1 } { ##1 } }
      }
    \__declare_package_seq_ginsert:Nn \g_declare_package_load_packages_seq { #1 }
  }


% 1 name
\cs_new:Nn \__declare_package_load:n
  {
    \seq_map_inline:cn { g_declare_package_ #1 _pkg_pre_hooks_seq }
      { \cs:w ##1 \cs_end: }

    \tl_set:Nn \l_tmpa_tl { g_declare_package_ #1 _pkg_add_ops_seq }
    \seq_clear:N \l_tmpa_seq
    \seq_if_exist:cT { \tl_use:N \l_tmpa_tl }
      {
        \seq_set_eq:Nc \l_tmpa_seq { \tl_use:N \l_tmpa_tl }
        \seq_map_inline:cn { g_declare_package_ #1 _pkg_rem_ops_seq }
          { \seq_remove_all:Nn \l_tmpa_seq { ##1 } }
      }
    \tl_set:Nx \l_tmpa_tl { \seq_use:Nn \l_tmpa_seq { ,~ } }
    \tl_if_blank:VF \l_tmpa_tl
      { \PassOptionsToPackage{\tl_use:N \l_tmpa_tl}{#1} }
    \RequirePackage{#1}

    \seq_map_inline:cn { g_declare_package_ #1 _pkg_post_hooks_seq }
      { \cs:w ##1 \cs_end: }
  }


% 1 name, 2 init code, 3 config code, 4 options, 5 prereqs, 6 antireqs, 7 load pre, 8 load post, 9 bool
\cs_new:Nn \__declare_package_pkg:nnnnnnnnn
  {
    \__declare_package_seq_ginsert:NnF \g_declare_package_packages_seq { #1 }
      {
        \PackageError{declare-package}
          {Packages should only be declared one.}
          {Package `#1' declared twice.}
      }

    \__declare_package_add_options:nn { #1 } { #4 }

    \bool_const:cn { c_declare_package_ #1 _pkg_load_bool } { #9 }
    \seq_const_from_clist:cn { c_declare_package_ #1 _pkg_prereqs_seq } { #5 }
    \seq_const_from_clist:cn { c_declare_package_ #1 _pkg_antireqs_seq } { #6 }

    \__declare_package_add_dependencies:nn { #1 } { #7 }
    \__declare_package_add_multi_dependencies:nn { #8 } { #1 }

    \tl_set:Nn \l_tmpa_tl { __declare_package_ #1 _pkg_init: }
    \cs_new:cn { \tl_use:N \l_tmpa_tl } { #2 }
    \__declare_package_add_pre_hooks_to_package:nV { #1 } \l_tmpa_tl

    \tl_set:Nn \l_tmpa_tl { __declare_package_ #1 _pkg_config: }
    \cs_new:cn { \tl_use:N \l_tmpa_tl } { #3 }
    \__declare_package_add_post_hooks_to_package:nV { #1 } \l_tmpa_tl
  }
\cs_generate_variant:Nn \__declare_package_pkg:nnnnnnnnn { nnnxxxxxn }


% 1 name, 2 options
\cs_new:Nn \__declare_package_add_options:nn
  { \__declare_package_seq_ginsert:cn { g_declare_package_ #1 _pkg_add_ops_seq } { #2 } }
\cs_generate_variant:Nn \__declare_package_add_options:nn { nx }


% 1 name, 2 options
\cs_new:Nn \__declare_package_remove_options:nn
  { \__declare_package_seq_ginsert:cn { g_declare_package_ #1 _pkg_rem_ops_seq } { #2 } }
\cs_generate_variant:Nn \__declare_package_remove_options:nn { nx }


% 1 packages, 2 dependencies
\cs_new:Nn \__declare_package_add_multi_dependencies:nn
  {
    \seq_set_from_clist:Nn \l_tmpa_seq { #1 }
    \seq_map_inline:Nn \l_tmpa_seq
      { \__declare_package_add_dependencies:nn { ##1 } { #2 } }
  }


% 1 package, 2 dependencies
\cs_new:Nn \__declare_package_add_dependencies:nn
  {
    \seq_set_from_clist:Nn \l_tmpa_seq { #2 }
    \seq_map_inline:Nn \l_tmpa_seq
      { \__declare_package_seq_ginsert:cn { g_declare_package_ ##1 _pkg_post_seq } { #1 } }
  }


% 1 packages, 2 code
\cs_new:Nn \__declare_package_before_packages:nn
  {
    \tl_set:Nx \l_tmpa_tl { \__declare_package_lambda:n { #2 } }
    \__declare_package_add_pre_hooks_to_packages:nx { #1 } { \tl_use:N \l_tmpa_tl } 
  }
\cs_generate_variant:Nn \__declare_package_before_packages:nn { xn }


% 1 packages, 2 code
\cs_new:Nn  \__declare_package_after_packages:nn
  {
    \tl_set:Nx \l_tmpa_tl { \__declare_package_lambda:n { #2 } }
    \__declare_package_add_post_hooks_to_packages:nx { #1 } { \tl_use:N \l_tmpa_tl } 
  }
\cs_generate_variant:Nn \__declare_package_after_packages:nn { xn }


% 1 package, 2 code
\cs_new:Nn \__declare_package_before_package:nn
  {
    \tl_set:Nx \l_tmpa_tl { \__declare_package_lambda:n { #2 } }
    \__declare_package_add_pre_hooks_to_package:nV { #1 } \l_tmpa_tl
  }


% 1 package, 2 code
\cs_new:Nn \__declare_package_after_package:nn
  {
    \tl_set:Nx \l_tmpa_tl { \__declare_package_lambda:n { #2 } }
    \__declare_package_add_post_hooks_to_package:nV { #1 } \l_tmpa_tl
  }


% 1 packages, 2 commands
\cs_new:Nn \__declare_package_add_pre_hooks_to_packages:nn
  {
    \seq_set_from_clist:Nn \l_tmpa_seq { #1 }
    \seq_map_inline:Nn \l_tmpa_seq
      { \__declare_package_add_pre_hooks_to_package:nn { ##1 } { #2 } }
  }
\cs_generate_variant:Nn \__declare_package_add_pre_hooks_to_packages:nn
  { nx, xn, xx, nV, Vn, VV }


% 1 packages, 2 commands
\cs_new:Nn \__declare_package_add_post_hooks_to_packages:nn
  {
    \seq_set_from_clist:Nn \l_tmpa_seq { #1 }
    \seq_map_inline:Nn \l_tmpa_seq
      { \__declare_package_add_post_hooks_to_package:nn { ##1 } { #2 } }
  }
\cs_generate_variant:Nn \__declare_package_add_post_hooks_to_packages:nn
  { nx, xn, xx, nV, Vn, VV }


% 1 package, 2 commands
\cs_new:Nn \__declare_package_add_pre_hooks_to_package:nn
  {
    \seq_set_from_clist:Nn \l_tmpa_seq { #2 }
    \seq_map_inline:Nn \l_tmpa_seq
      { \__declare_package_seq_ginsert:cn { g_declare_package_ #1 _pkg_pre_hooks_seq } { ##1 } }
  }
\cs_generate_variant:Nn \__declare_package_add_pre_hooks_to_package:nn { nx, nV }


% 1 package, 2 commands
\cs_new:Nn \__declare_package_add_post_hooks_to_package:nn
  {
    \seq_set_from_clist:Nn \l_tmpa_seq { #2 }
    \seq_map_inline:Nn \l_tmpa_seq
      { \__declare_package_seq_ginsert:cn { g_declare_package_ #1 _pkg_post_hooks_seq } { ##1 } }
  }
\cs_generate_variant:Nn \__declare_package_add_post_hooks_to_package:nn { nx, nV }


% 1 seq, 2 elem
\cs_new:Nn \__declare_package_seq_ginsert:Nn
  { \__declare_package_seq_ginsert:NnT #1 { #2 } {} }
\cs_generate_variant:Nn \__declare_package_seq_ginsert:Nn { cn }


% 1 seq, 2 elem, T when pushed, F when in
\prg_new_conditional:Nnn \__declare_package_seq_ginsert:Nn { p, T, F, TF }
  {
    \__declare_package_new:nN { seq } #1
    \seq_if_in:NnTF #1 { #2 }
    { \prg_return_false: }
    { \seq_gpush:Nn #1 { #2 } \prg_return_true: }
  }
\prg_generate_conditional_variant:Nnn \__declare_package_seq_ginsert:Nn { cn } { p, T, F, TF }


% 1 type, 2 var
\cs_new:Nn \__declare_package_new:nN
  { \cs:w #1 _if_exist:NF \cs_end: #2 { \cs:w #1 _new:N \cs_end: #2 } }
\cs_generate_variant:Nn \__declare_package_new:nN { nc }


% 1 code
\cs_new:Nn \__declare_package_lambda:n
  {
    \tl_set:Nn \l_tmpa_tl
      {
        __declare_package_lambda_
        \int_use:N \g_declage_package_lambda_int
        :
      }
    \cs_new:cn { \tl_use:N \l_tmpa_tl } { #1 }
    \int_incr:N \g_declare_package_lambda_int
    \tl_use:N \l_tmpa_tl
  }
